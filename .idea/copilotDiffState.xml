<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/backend/convolve.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/convolve.py" />
              <option name="originalContent" value="import time&#10;&#10;import numpy as np&#10;from numpy.lib.stride_tricks import as_strided&#10;&#10;def convolve(image, conv_filter):&#10;    filter_height, filter_width, in_channels = conv_filter.shape&#10;    img_height, img_width, img_channels = image.shape&#10;&#10;    assert in_channels == img_channels, &quot;Filter and image must have the same number of channels.&quot;&#10;&#10;    pad_h = (filter_height - 1) // 2&#10;    pad_w = (filter_width - 1) // 2&#10;&#10;    padded_image = np.pad(&#10;        image,&#10;        ((pad_h, pad_h), (pad_w, pad_w), (0, 0)),&#10;        mode='constant'&#10;    )&#10;&#10;    # Use stride_tricks to create a view of the image with sliding windows&#10;    # This avoids explicit loops and is much faster&#10;    view_shape = (img_height, img_width, filter_height, filter_width, in_channels)&#10;    strides = padded_image.strides[:2] + padded_image.strides&#10;    sub_matrices = as_strided(padded_image, shape=view_shape, strides=strides)&#10;&#10;    # Perform convolution using vectorized operations (einsum is great for this)&#10;    # This computes the sum of the element-wise product of the windows and the filter&#10;    output = np.einsum('h w H W c, H W c -&gt; h w c', sub_matrices, conv_filter)&#10;&#10;    return output" />
              <option name="updatedContent" value="import time&#10;&#10;import numpy as np&#10;from numpy.lib.stride_tricks import as_strided&#10;&#10;def convolve(image, conv_filter):&#10;    filter_height, filter_width, in_channels = conv_filter.shape&#10;    img_height, img_width, img_channels = image.shape&#10;&#10;    assert in_channels == img_channels, &quot;Filter and image must have the same number of channels.&quot;&#10;&#10;    pad_h = (filter_height - 1) // 2&#10;    pad_w = (filter_width - 1) // 2&#10;&#10;    padded_image = np.pad(&#10;        image,&#10;        ((pad_h, pad_h), (pad_w, pad_w), (0, 0)),&#10;        mode='constant'&#10;    )&#10;&#10;    # Use stride_tricks to create a view of the image with sliding windows&#10;    # This avoids explicit loops and is much faster&#10;    view_shape = (img_height, img_width, filter_height, filter_width, in_channels)&#10;    strides = padded_image.strides[:2] + padded_image.strides&#10;    sub_matrices = as_strided(padded_image, shape=view_shape, strides=strides)&#10;&#10;    # Perform convolution using vectorized operations (einsum is great for this)&#10;    # This computes the sum of the element-wise product of the windows and the filter&#10;    # The output should be 2D (h, w) for a single filter application.&#10;    output = np.einsum('h w H W c, H W c -&gt; h w', sub_matrices, conv_filter)&#10;&#10;    return output" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/backend/max_pool.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/max_pool.py" />
              <option name="originalContent" value="import numpy as np&#10;&#10;def max_pool(image, pool_size=2, stride=2):&#10;    img_height, img_width, channels = image.shape&#10;    out_height = (img_height - pool_size) // stride + 1&#10;    out_width = (img_width - pool_size) // stride + 1&#10;    pooled = np.zeros((out_height, out_width, channels))&#10;&#10;    for c in range(channels):&#10;        for i in range(out_height):&#10;            for j in range(out_width):&#10;                h_start = i * stride&#10;                w_start = j * stride&#10;                window = image[h_start:h_start+pool_size, w_start:w_start+pool_size, c]&#10;                pooled[i, j, c] = np.max(window)&#10;    return pooled" />
              <option name="updatedContent" value="import numpy as np&#10;from numpy.lib.stride_tricks import as_strided&#10;&#10;def max_pool(image, pool_size=2, stride=2):&#10;    img_height, img_width, channels = image.shape&#10;    out_height = (img_height - pool_size) // stride + 1&#10;    out_width = (img_width - pool_size) // stride + 1&#10;&#10;    # Create a view of the image with sliding windows&#10;    view_shape = (out_height, out_width, channels, pool_size, pool_size)&#10;    &#10;    # Calculate strides for the view&#10;    # Stride for height, width, channels, then inside the pool window&#10;    strides = (&#10;        stride * image.strides[0], &#10;        stride * image.strides[1], &#10;        image.strides[2], &#10;        image.strides[0], &#10;        image.strides[1]&#10;    )&#10;    &#10;    windows = as_strided(image, shape=view_shape, strides=strides)&#10;&#10;    # Find the maximum value in each window across the pool_size x pool_size dimensions&#10;    # The axes to reduce are the last two (pool_height and pool_width)&#10;    pooled = np.max(windows, axis=(3, 4))&#10;    &#10;    return pooled" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>